//! Standard library of shapes and transforms
//!
//! These shapes are designed for use in higher-level languages and tools.
//! Each shape is a single `struct` with named member variables.  The "output"
//! of the shape is always a [`Tree`], and can be generated by calling
//! `Tree::from(..)`.  Shape member variables can always be represented by
//! variants of [`Value`](types::Value) (checked by a unit test).
//!
//! Every shape implements `Facet + Clone + Send + Sync + Into<Tree> + 'static`.
//! When generating bindings, users are expected to inspect the shape's type
//! using annotations provided by the [`facet`] crate; to iterate over the
//! entire shape library, use [`ShapeVisitor`] and [`visit_shapes`].
//!
//! For an example of binding shapes into a dynamic language, look at the
//! implementation of [`fidget::rhai::shapes`](crate::rhai::shapes)
//! (specifically the internal `register_shape` function).
use crate::context::Tree;
use facet::Facet;

pub mod types;
use types::{Axis, Plane, Vec2, Vec3};

////////////////////////////////////////////////////////////////////////////////
// 2D shapes

/// 2D circle
#[derive(Clone, Facet)]
pub struct Circle {
    /// Center of the circle (in XY)
    #[facet(default = Vec2::new(0.0, 0.0))]
    pub center: Vec2,
    /// Circle radius
    #[facet(default = 1.0)]
    pub radius: f64,
}

impl From<Circle> for Tree {
    fn from(v: Circle) -> Self {
        let (x, y, _) = Tree::axes();
        ((x - v.center.x).square() + (y - v.center.y).square()).sqrt()
            - v.radius
    }
}

////////////////////////////////////////////////////////////////////////////////
// 3D shapes

/// 3D sphere
#[derive(Clone, Facet)]
pub struct Sphere {
    /// Center of the circle (in XYZ)
    #[facet(default = Vec3::new(0.0, 0.0, 0.0))]
    pub center: Vec3,
    /// Sphere radius
    #[facet(default = 1.0)]
    pub radius: f64,
}

impl From<Sphere> for Tree {
    fn from(v: Sphere) -> Self {
        let (x, y, z) = Tree::axes();
        ((x - v.center.x).square()
            + (y - v.center.y).square()
            + (z - v.center.z).square())
        .sqrt()
            - v.radius
    }
}

////////////////////////////////////////////////////////////////////////////////
// CSG operations

/// Take the union of a set of shapes
///
/// If the input is empty, returns an constant empty tree (at +∞)
#[derive(Clone, Facet)]
pub struct Union {
    /// List of shapes to merge
    pub input: Vec<Tree>,
}

impl From<Union> for Tree {
    fn from(v: Union) -> Self {
        if v.input.is_empty() {
            // XXX should this be an error instead?
            Tree::constant(f64::INFINITY)
        } else {
            fn recurse(s: &[Tree]) -> Tree {
                match s.len() {
                    1 => s[0].clone(),
                    n => recurse(&s[..n / 2]).min(recurse(&s[n / 2..])),
                }
            }
            recurse(&v.input)
        }
    }
}

/// Take the intersection of a set of shapes
///
/// If the input is empty, returns a constant full tree (at -∞)
#[derive(Clone, Facet)]
pub struct Intersection {
    /// List of shapes to intersect
    pub input: Vec<Tree>,
}

impl From<Intersection> for Tree {
    fn from(v: Intersection) -> Self {
        if v.input.is_empty() {
            // XXX should this be an error instead?
            Tree::constant(-f64::INFINITY)
        } else {
            fn recurse(s: &[Tree]) -> Tree {
                match s.len() {
                    1 => s[0].clone(),
                    n => recurse(&s[..n / 2]).max(recurse(&s[n / 2..])),
                }
            }
            recurse(&v.input)
        }
    }
}

/// Computes the inverse of a shape
#[derive(Clone, Facet)]
pub struct Inverse {
    /// Shape to invert
    pub shape: Tree,
}

impl From<Inverse> for Tree {
    fn from(v: Inverse) -> Self {
        -v.shape
    }
}

/// Take the difference of two shapes
#[derive(Clone, Facet)]
pub struct Difference {
    /// Original shape
    pub shape: Tree,
    /// Shape to be subtracted from the original
    pub cutout: Tree,
}

impl From<Difference> for Tree {
    fn from(v: Difference) -> Self {
        v.shape.max(-v.cutout)
    }
}

////////////////////////////////////////////////////////////////////////////////
// Transforms

/// Move a shape
#[derive(Clone, Facet)]
pub struct Move {
    /// Shape to move
    pub shape: Tree,
    /// Position offset
    #[facet(default = Vec3::new(0.0, 0.0, 0.0))]
    pub offset: Vec3,
}

impl From<Move> for Tree {
    fn from(v: Move) -> Self {
        v.shape.remap_affine(nalgebra::convert(
            nalgebra::Translation3::<f64>::new(
                -v.offset.x,
                -v.offset.y,
                -v.offset.z,
            ),
        ))
    }
}

/// Non-uniform scaling
#[derive(Clone, Facet)]
pub struct Scale {
    /// Shape to scale
    pub shape: Tree,
    /// Scale to apply on each axis
    #[facet(default = Vec3::new(1.0, 1.0, 1.0))]
    pub scale: Vec3,
}

impl From<Scale> for Tree {
    fn from(v: Scale) -> Self {
        v.shape
            .remap_affine(nalgebra::convert(nalgebra::Scale3::<f64>::new(
                1.0 / v.scale.x,
                1.0 / v.scale.y,
                1.0 / v.scale.z,
            )))
    }
}

/// Reflection
#[derive(Clone, Facet)]
pub struct Reflect {
    /// Shape to reflect
    pub shape: Tree,

    /// Plane about which to reflect the shape
    #[facet(default = Plane::YZ)]
    pub plane: Plane,
}

impl From<Reflect> for Tree {
    fn from(v: Reflect) -> Self {
        let a = v.plane.axis.vec();
        let (x, y, z) = Tree::axes();
        let d = a.x * x.clone() + a.y * y.clone() + a.z * z.clone()
            - v.plane.offset;
        let scale: Tree = 2.0 * d;
        // TODO could we use nalgebra::Reflection3 here to make the transform
        // affine?  For some reason, it doesn't implement the right SubSet
        v.shape.remap_xyz(
            x - scale.clone() * a.x,
            y - scale.clone() * a.y,
            z - scale * a.z,
        )
    }
}

/// Reflection about the X axis
#[derive(Clone, Facet)]
pub struct ReflectX {
    /// Shape to reflect
    pub shape: Tree,

    /// Plane about which to reflect the shape
    #[facet(default = 0.0)]
    pub offset: f64,
}

impl From<ReflectX> for Tree {
    fn from(v: ReflectX) -> Self {
        Reflect {
            shape: v.shape,
            plane: Plane {
                axis: Axis::X,
                offset: v.offset,
            },
        }
        .into()
    }
}

/// Reflection about the Y axis
#[derive(Clone, Facet)]
pub struct ReflectY {
    /// Shape to reflect
    pub shape: Tree,

    /// Plane about which to reflect the shape
    #[facet(default = 0.0)]
    pub offset: f64,
}

impl From<ReflectY> for Tree {
    fn from(v: ReflectY) -> Self {
        Reflect {
            shape: v.shape,
            plane: Plane {
                axis: Axis::Y,
                offset: v.offset,
            },
        }
        .into()
    }
}

/// Reflection about the Z axis
#[derive(Clone, Facet)]
pub struct ReflectZ {
    /// Shape to reflect
    pub shape: Tree,

    /// Plane about which to reflect the shape
    #[facet(default = 0.0)]
    pub offset: f64,
}

impl From<ReflectZ> for Tree {
    fn from(v: ReflectZ) -> Self {
        Reflect {
            shape: v.shape,
            plane: Plane {
                axis: Axis::Z,
                offset: v.offset,
            },
        }
        .into()
    }
}

////////////////////////////////////////////////////////////////////////////////

/// Trait for a type which can visit each of the shapes in our library
pub trait ShapeVisitor {
    /// Process the given type
    fn visit<T: Facet<'static> + Clone + Send + Sync + Into<Tree> + 'static>(
        &mut self,
    );
}

/// Maps a shape visitor across all shape definitions
pub fn visit_shapes<V: ShapeVisitor>(visitor: &mut V) {
    visitor.visit::<Circle>();
    visitor.visit::<Sphere>();

    visitor.visit::<Move>();
    visitor.visit::<Scale>();
    visitor.visit::<Reflect>();
    visitor.visit::<ReflectX>();
    visitor.visit::<ReflectY>();
    visitor.visit::<ReflectZ>();

    visitor.visit::<Union>();
    visitor.visit::<Intersection>();
    visitor.visit::<Difference>();
    visitor.visit::<Inverse>();
}

////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn circle_docstring() {
        assert_eq!(Circle::SHAPE.doc, &[" 2D circle"]);
    }

    #[test]
    fn scale_default_fn() {
        let facet::Type::User(facet::UserType::Struct(s)) = Scale::SHAPE.ty
        else {
            panic!();
        };
        for f in s.fields {
            if f.name == "scale" {
                let Some(f) = f.vtable.default_fn else {
                    panic!()
                };
                let mut v = std::mem::MaybeUninit::<Vec3>::uninit();
                let ptr = facet::PtrUninit::new(&mut v);
                let v: Vec3 = unsafe { *f(ptr).as_ptr() };
                assert_eq!(v.x, 1.0);
                assert_eq!(v.y, 1.0);
                assert_eq!(v.z, 1.0);
            } else {
                assert!(f.vtable.default_fn.is_none());
            }
        }
    }
}
